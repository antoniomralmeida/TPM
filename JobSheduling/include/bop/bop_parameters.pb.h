// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bop/bop_parameters.proto

#ifndef PROTOBUF_bop_2fbop_5fparameters_2eproto__INCLUDED
#define PROTOBUF_bop_2fbop_5fparameters_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace operations_research {
namespace bop {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_bop_2fbop_5fparameters_2eproto();
void protobuf_AssignDesc_bop_2fbop_5fparameters_2eproto();
void protobuf_ShutdownFile_bop_2fbop_5fparameters_2eproto();

class BopOptimizerMethod;
class BopParameters;
class BopSolverOptimizerSet;

enum BopOptimizerMethod_OptimizerType {
  BopOptimizerMethod_OptimizerType_SAT_CORE_BASED = 0,
  BopOptimizerMethod_OptimizerType_SAT_LINEAR_SEARCH = 15,
  BopOptimizerMethod_OptimizerType_LINEAR_RELAXATION = 1,
  BopOptimizerMethod_OptimizerType_LOCAL_SEARCH = 2,
  BopOptimizerMethod_OptimizerType_RANDOM_FIRST_SOLUTION = 3,
  BopOptimizerMethod_OptimizerType_RANDOM_CONSTRAINT_LNS = 4,
  BopOptimizerMethod_OptimizerType_RANDOM_VARIABLE_LNS = 5,
  BopOptimizerMethod_OptimizerType_COMPLETE_LNS = 7,
  BopOptimizerMethod_OptimizerType_LP_FIRST_SOLUTION = 8,
  BopOptimizerMethod_OptimizerType_OBJECTIVE_FIRST_SOLUTION = 9,
  BopOptimizerMethod_OptimizerType_USER_GUIDED_FIRST_SOLUTION = 14,
  BopOptimizerMethod_OptimizerType_RANDOM_CONSTRAINT_LNS_GUIDED_BY_LP = 11,
  BopOptimizerMethod_OptimizerType_RANDOM_VARIABLE_LNS_GUIDED_BY_LP = 12,
  BopOptimizerMethod_OptimizerType_RELATION_GRAPH_LNS = 16,
  BopOptimizerMethod_OptimizerType_RELATION_GRAPH_LNS_GUIDED_BY_LP = 17
};
bool BopOptimizerMethod_OptimizerType_IsValid(int value);
const BopOptimizerMethod_OptimizerType BopOptimizerMethod_OptimizerType_OptimizerType_MIN = BopOptimizerMethod_OptimizerType_SAT_CORE_BASED;
const BopOptimizerMethod_OptimizerType BopOptimizerMethod_OptimizerType_OptimizerType_MAX = BopOptimizerMethod_OptimizerType_RELATION_GRAPH_LNS_GUIDED_BY_LP;
const int BopOptimizerMethod_OptimizerType_OptimizerType_ARRAYSIZE = BopOptimizerMethod_OptimizerType_OptimizerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BopOptimizerMethod_OptimizerType_descriptor();
inline const ::std::string& BopOptimizerMethod_OptimizerType_Name(BopOptimizerMethod_OptimizerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BopOptimizerMethod_OptimizerType_descriptor(), value);
}
inline bool BopOptimizerMethod_OptimizerType_Parse(
    const ::std::string& name, BopOptimizerMethod_OptimizerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BopOptimizerMethod_OptimizerType>(
    BopOptimizerMethod_OptimizerType_descriptor(), name, value);
}
enum BopParameters_ThreadSynchronizationType {
  BopParameters_ThreadSynchronizationType_NO_SYNCHRONIZATION = 0,
  BopParameters_ThreadSynchronizationType_SYNCHRONIZE_ALL = 1,
  BopParameters_ThreadSynchronizationType_SYNCHRONIZE_ON_RIGHT = 2
};
bool BopParameters_ThreadSynchronizationType_IsValid(int value);
const BopParameters_ThreadSynchronizationType BopParameters_ThreadSynchronizationType_ThreadSynchronizationType_MIN = BopParameters_ThreadSynchronizationType_NO_SYNCHRONIZATION;
const BopParameters_ThreadSynchronizationType BopParameters_ThreadSynchronizationType_ThreadSynchronizationType_MAX = BopParameters_ThreadSynchronizationType_SYNCHRONIZE_ON_RIGHT;
const int BopParameters_ThreadSynchronizationType_ThreadSynchronizationType_ARRAYSIZE = BopParameters_ThreadSynchronizationType_ThreadSynchronizationType_MAX + 1;

const ::google::protobuf::EnumDescriptor* BopParameters_ThreadSynchronizationType_descriptor();
inline const ::std::string& BopParameters_ThreadSynchronizationType_Name(BopParameters_ThreadSynchronizationType value) {
  return ::google::protobuf::internal::NameOfEnum(
    BopParameters_ThreadSynchronizationType_descriptor(), value);
}
inline bool BopParameters_ThreadSynchronizationType_Parse(
    const ::std::string& name, BopParameters_ThreadSynchronizationType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BopParameters_ThreadSynchronizationType>(
    BopParameters_ThreadSynchronizationType_descriptor(), name, value);
}
// ===================================================================

class BopOptimizerMethod : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.bop.BopOptimizerMethod) */ {
 public:
  BopOptimizerMethod();
  virtual ~BopOptimizerMethod();

  BopOptimizerMethod(const BopOptimizerMethod& from);

  inline BopOptimizerMethod& operator=(const BopOptimizerMethod& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BopOptimizerMethod& default_instance();

  void Swap(BopOptimizerMethod* other);

  // implements Message ----------------------------------------------

  inline BopOptimizerMethod* New() const { return New(NULL); }

  BopOptimizerMethod* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BopOptimizerMethod& from);
  void MergeFrom(const BopOptimizerMethod& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BopOptimizerMethod* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BopOptimizerMethod_OptimizerType OptimizerType;
  static const OptimizerType SAT_CORE_BASED =
    BopOptimizerMethod_OptimizerType_SAT_CORE_BASED;
  static const OptimizerType SAT_LINEAR_SEARCH =
    BopOptimizerMethod_OptimizerType_SAT_LINEAR_SEARCH;
  static const OptimizerType LINEAR_RELAXATION =
    BopOptimizerMethod_OptimizerType_LINEAR_RELAXATION;
  static const OptimizerType LOCAL_SEARCH =
    BopOptimizerMethod_OptimizerType_LOCAL_SEARCH;
  static const OptimizerType RANDOM_FIRST_SOLUTION =
    BopOptimizerMethod_OptimizerType_RANDOM_FIRST_SOLUTION;
  static const OptimizerType RANDOM_CONSTRAINT_LNS =
    BopOptimizerMethod_OptimizerType_RANDOM_CONSTRAINT_LNS;
  static const OptimizerType RANDOM_VARIABLE_LNS =
    BopOptimizerMethod_OptimizerType_RANDOM_VARIABLE_LNS;
  static const OptimizerType COMPLETE_LNS =
    BopOptimizerMethod_OptimizerType_COMPLETE_LNS;
  static const OptimizerType LP_FIRST_SOLUTION =
    BopOptimizerMethod_OptimizerType_LP_FIRST_SOLUTION;
  static const OptimizerType OBJECTIVE_FIRST_SOLUTION =
    BopOptimizerMethod_OptimizerType_OBJECTIVE_FIRST_SOLUTION;
  static const OptimizerType USER_GUIDED_FIRST_SOLUTION =
    BopOptimizerMethod_OptimizerType_USER_GUIDED_FIRST_SOLUTION;
  static const OptimizerType RANDOM_CONSTRAINT_LNS_GUIDED_BY_LP =
    BopOptimizerMethod_OptimizerType_RANDOM_CONSTRAINT_LNS_GUIDED_BY_LP;
  static const OptimizerType RANDOM_VARIABLE_LNS_GUIDED_BY_LP =
    BopOptimizerMethod_OptimizerType_RANDOM_VARIABLE_LNS_GUIDED_BY_LP;
  static const OptimizerType RELATION_GRAPH_LNS =
    BopOptimizerMethod_OptimizerType_RELATION_GRAPH_LNS;
  static const OptimizerType RELATION_GRAPH_LNS_GUIDED_BY_LP =
    BopOptimizerMethod_OptimizerType_RELATION_GRAPH_LNS_GUIDED_BY_LP;
  static inline bool OptimizerType_IsValid(int value) {
    return BopOptimizerMethod_OptimizerType_IsValid(value);
  }
  static const OptimizerType OptimizerType_MIN =
    BopOptimizerMethod_OptimizerType_OptimizerType_MIN;
  static const OptimizerType OptimizerType_MAX =
    BopOptimizerMethod_OptimizerType_OptimizerType_MAX;
  static const int OptimizerType_ARRAYSIZE =
    BopOptimizerMethod_OptimizerType_OptimizerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OptimizerType_descriptor() {
    return BopOptimizerMethod_OptimizerType_descriptor();
  }
  static inline const ::std::string& OptimizerType_Name(OptimizerType value) {
    return BopOptimizerMethod_OptimizerType_Name(value);
  }
  static inline bool OptimizerType_Parse(const ::std::string& name,
      OptimizerType* value) {
    return BopOptimizerMethod_OptimizerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .operations_research.bop.BopOptimizerMethod.OptimizerType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::operations_research::bop::BopOptimizerMethod_OptimizerType type() const;
  void set_type(::operations_research::bop::BopOptimizerMethod_OptimizerType value);

  // @@protoc_insertion_point(class_scope:operations_research.bop.BopOptimizerMethod)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  friend void  protobuf_AddDesc_bop_2fbop_5fparameters_2eproto();
  friend void protobuf_AssignDesc_bop_2fbop_5fparameters_2eproto();
  friend void protobuf_ShutdownFile_bop_2fbop_5fparameters_2eproto();

  void InitAsDefaultInstance();
  static BopOptimizerMethod* default_instance_;
};
// -------------------------------------------------------------------

class BopSolverOptimizerSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.bop.BopSolverOptimizerSet) */ {
 public:
  BopSolverOptimizerSet();
  virtual ~BopSolverOptimizerSet();

  BopSolverOptimizerSet(const BopSolverOptimizerSet& from);

  inline BopSolverOptimizerSet& operator=(const BopSolverOptimizerSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BopSolverOptimizerSet& default_instance();

  void Swap(BopSolverOptimizerSet* other);

  // implements Message ----------------------------------------------

  inline BopSolverOptimizerSet* New() const { return New(NULL); }

  BopSolverOptimizerSet* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BopSolverOptimizerSet& from);
  void MergeFrom(const BopSolverOptimizerSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BopSolverOptimizerSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .operations_research.bop.BopOptimizerMethod methods = 1;
  int methods_size() const;
  void clear_methods();
  static const int kMethodsFieldNumber = 1;
  const ::operations_research::bop::BopOptimizerMethod& methods(int index) const;
  ::operations_research::bop::BopOptimizerMethod* mutable_methods(int index);
  ::operations_research::bop::BopOptimizerMethod* add_methods();
  ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopOptimizerMethod >*
      mutable_methods();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopOptimizerMethod >&
      methods() const;

  // @@protoc_insertion_point(class_scope:operations_research.bop.BopSolverOptimizerSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopOptimizerMethod > methods_;
  friend void  protobuf_AddDesc_bop_2fbop_5fparameters_2eproto();
  friend void protobuf_AssignDesc_bop_2fbop_5fparameters_2eproto();
  friend void protobuf_ShutdownFile_bop_2fbop_5fparameters_2eproto();

  void InitAsDefaultInstance();
  static BopSolverOptimizerSet* default_instance_;
};
// -------------------------------------------------------------------

class BopParameters : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:operations_research.bop.BopParameters) */ {
 public:
  BopParameters();
  virtual ~BopParameters();

  BopParameters(const BopParameters& from);

  inline BopParameters& operator=(const BopParameters& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BopParameters& default_instance();

  void Swap(BopParameters* other);

  // implements Message ----------------------------------------------

  inline BopParameters* New() const { return New(NULL); }

  BopParameters* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BopParameters& from);
  void MergeFrom(const BopParameters& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(BopParameters* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef BopParameters_ThreadSynchronizationType ThreadSynchronizationType;
  static const ThreadSynchronizationType NO_SYNCHRONIZATION =
    BopParameters_ThreadSynchronizationType_NO_SYNCHRONIZATION;
  static const ThreadSynchronizationType SYNCHRONIZE_ALL =
    BopParameters_ThreadSynchronizationType_SYNCHRONIZE_ALL;
  static const ThreadSynchronizationType SYNCHRONIZE_ON_RIGHT =
    BopParameters_ThreadSynchronizationType_SYNCHRONIZE_ON_RIGHT;
  static inline bool ThreadSynchronizationType_IsValid(int value) {
    return BopParameters_ThreadSynchronizationType_IsValid(value);
  }
  static const ThreadSynchronizationType ThreadSynchronizationType_MIN =
    BopParameters_ThreadSynchronizationType_ThreadSynchronizationType_MIN;
  static const ThreadSynchronizationType ThreadSynchronizationType_MAX =
    BopParameters_ThreadSynchronizationType_ThreadSynchronizationType_MAX;
  static const int ThreadSynchronizationType_ARRAYSIZE =
    BopParameters_ThreadSynchronizationType_ThreadSynchronizationType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ThreadSynchronizationType_descriptor() {
    return BopParameters_ThreadSynchronizationType_descriptor();
  }
  static inline const ::std::string& ThreadSynchronizationType_Name(ThreadSynchronizationType value) {
    return BopParameters_ThreadSynchronizationType_Name(value);
  }
  static inline bool ThreadSynchronizationType_Parse(const ::std::string& name,
      ThreadSynchronizationType* value) {
    return BopParameters_ThreadSynchronizationType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional double max_time_in_seconds = 1 [default = inf];
  bool has_max_time_in_seconds() const;
  void clear_max_time_in_seconds();
  static const int kMaxTimeInSecondsFieldNumber = 1;
  double max_time_in_seconds() const;
  void set_max_time_in_seconds(double value);

  // optional double max_deterministic_time = 27 [default = inf];
  bool has_max_deterministic_time() const;
  void clear_max_deterministic_time();
  static const int kMaxDeterministicTimeFieldNumber = 27;
  double max_deterministic_time() const;
  void set_max_deterministic_time(double value);

  // optional double lp_max_deterministic_time = 37 [default = 1];
  bool has_lp_max_deterministic_time() const;
  void clear_lp_max_deterministic_time();
  static const int kLpMaxDeterministicTimeFieldNumber = 37;
  double lp_max_deterministic_time() const;
  void set_lp_max_deterministic_time(double value);

  // optional int32 max_number_of_consecutive_failing_optimizer_calls = 35;
  bool has_max_number_of_consecutive_failing_optimizer_calls() const;
  void clear_max_number_of_consecutive_failing_optimizer_calls();
  static const int kMaxNumberOfConsecutiveFailingOptimizerCallsFieldNumber = 35;
  ::google::protobuf::int32 max_number_of_consecutive_failing_optimizer_calls() const;
  void set_max_number_of_consecutive_failing_optimizer_calls(::google::protobuf::int32 value);

  // optional double relative_gap_limit = 28 [default = 0.0001];
  bool has_relative_gap_limit() const;
  void clear_relative_gap_limit();
  static const int kRelativeGapLimitFieldNumber = 28;
  double relative_gap_limit() const;
  void set_relative_gap_limit(double value);

  // optional int32 max_num_decisions_in_ls = 2 [default = 4];
  bool has_max_num_decisions_in_ls() const;
  void clear_max_num_decisions_in_ls();
  static const int kMaxNumDecisionsInLsFieldNumber = 2;
  ::google::protobuf::int32 max_num_decisions_in_ls() const;
  void set_max_num_decisions_in_ls(::google::protobuf::int32 value);

  // optional int32 max_num_broken_constraints_in_ls = 38 [default = 2147483647];
  bool has_max_num_broken_constraints_in_ls() const;
  void clear_max_num_broken_constraints_in_ls();
  static const int kMaxNumBrokenConstraintsInLsFieldNumber = 38;
  ::google::protobuf::int32 max_num_broken_constraints_in_ls() const;
  void set_max_num_broken_constraints_in_ls(::google::protobuf::int32 value);

  // optional bool log_search_progress = 14 [default = false];
  bool has_log_search_progress() const;
  void clear_log_search_progress();
  static const int kLogSearchProgressFieldNumber = 14;
  bool log_search_progress() const;
  void set_log_search_progress(bool value);

  // optional bool compute_estimated_impact = 3 [default = true];
  bool has_compute_estimated_impact() const;
  void clear_compute_estimated_impact();
  static const int kComputeEstimatedImpactFieldNumber = 3;
  bool compute_estimated_impact() const;
  void set_compute_estimated_impact(bool value);

  // optional bool prune_search_tree = 4 [default = false];
  bool has_prune_search_tree() const;
  void clear_prune_search_tree();
  static const int kPruneSearchTreeFieldNumber = 4;
  bool prune_search_tree() const;
  void set_prune_search_tree(bool value);

  // optional bool sort_constraints_by_num_terms = 5 [default = false];
  bool has_sort_constraints_by_num_terms() const;
  void clear_sort_constraints_by_num_terms();
  static const int kSortConstraintsByNumTermsFieldNumber = 5;
  bool sort_constraints_by_num_terms() const;
  void set_sort_constraints_by_num_terms(bool value);

  // optional bool use_random_lns = 6 [default = true];
  bool has_use_random_lns() const;
  void clear_use_random_lns();
  static const int kUseRandomLnsFieldNumber = 6;
  bool use_random_lns() const;
  void set_use_random_lns(bool value);

  // optional int32 random_seed = 7 [default = 0];
  bool has_random_seed() const;
  void clear_random_seed();
  static const int kRandomSeedFieldNumber = 7;
  ::google::protobuf::int32 random_seed() const;
  void set_random_seed(::google::protobuf::int32 value);

  // optional int32 num_relaxed_vars = 8 [default = 10];
  bool has_num_relaxed_vars() const;
  void clear_num_relaxed_vars();
  static const int kNumRelaxedVarsFieldNumber = 8;
  ::google::protobuf::int32 num_relaxed_vars() const;
  void set_num_relaxed_vars(::google::protobuf::int32 value);

  // optional int32 max_number_of_conflicts_in_random_lns = 9 [default = 2500];
  bool has_max_number_of_conflicts_in_random_lns() const;
  void clear_max_number_of_conflicts_in_random_lns();
  static const int kMaxNumberOfConflictsInRandomLnsFieldNumber = 9;
  ::google::protobuf::int32 max_number_of_conflicts_in_random_lns() const;
  void set_max_number_of_conflicts_in_random_lns(::google::protobuf::int32 value);

  // optional int32 num_random_lns_tries = 10 [default = 1];
  bool has_num_random_lns_tries() const;
  void clear_num_random_lns_tries();
  static const int kNumRandomLnsTriesFieldNumber = 10;
  ::google::protobuf::int32 num_random_lns_tries() const;
  void set_num_random_lns_tries(::google::protobuf::int32 value);

  // optional int64 max_number_of_backtracks_in_ls = 11 [default = 100000000];
  bool has_max_number_of_backtracks_in_ls() const;
  void clear_max_number_of_backtracks_in_ls();
  static const int kMaxNumberOfBacktracksInLsFieldNumber = 11;
  ::google::protobuf::int64 max_number_of_backtracks_in_ls() const;
  void set_max_number_of_backtracks_in_ls(::google::protobuf::int64 value);

  // optional bool use_lp_lns = 12 [default = true];
  bool has_use_lp_lns() const;
  void clear_use_lp_lns();
  static const int kUseLpLnsFieldNumber = 12;
  bool use_lp_lns() const;
  void set_use_lp_lns(bool value);

  // optional bool use_sat_to_choose_lns_neighbourhood = 15 [default = true];
  bool has_use_sat_to_choose_lns_neighbourhood() const;
  void clear_use_sat_to_choose_lns_neighbourhood();
  static const int kUseSatToChooseLnsNeighbourhoodFieldNumber = 15;
  bool use_sat_to_choose_lns_neighbourhood() const;
  void set_use_sat_to_choose_lns_neighbourhood(bool value);

  // optional int32 max_number_of_conflicts_for_quick_check = 16 [default = 10];
  bool has_max_number_of_conflicts_for_quick_check() const;
  void clear_max_number_of_conflicts_for_quick_check();
  static const int kMaxNumberOfConflictsForQuickCheckFieldNumber = 16;
  ::google::protobuf::int32 max_number_of_conflicts_for_quick_check() const;
  void set_max_number_of_conflicts_for_quick_check(::google::protobuf::int32 value);

  // optional bool use_symmetry = 17 [default = false];
  bool has_use_symmetry() const;
  void clear_use_symmetry();
  static const int kUseSymmetryFieldNumber = 17;
  bool use_symmetry() const;
  void set_use_symmetry(bool value);

  // optional bool exploit_symmetry_in_sat_first_solution = 40 [default = false];
  bool has_exploit_symmetry_in_sat_first_solution() const;
  void clear_exploit_symmetry_in_sat_first_solution();
  static const int kExploitSymmetryInSatFirstSolutionFieldNumber = 40;
  bool exploit_symmetry_in_sat_first_solution() const;
  void set_exploit_symmetry_in_sat_first_solution(bool value);

  // optional int32 max_number_of_conflicts_in_random_solution_generation = 20 [default = 500];
  bool has_max_number_of_conflicts_in_random_solution_generation() const;
  void clear_max_number_of_conflicts_in_random_solution_generation();
  static const int kMaxNumberOfConflictsInRandomSolutionGenerationFieldNumber = 20;
  ::google::protobuf::int32 max_number_of_conflicts_in_random_solution_generation() const;
  void set_max_number_of_conflicts_in_random_solution_generation(::google::protobuf::int32 value);

  // optional int64 max_number_of_explored_assignments_per_try_in_ls = 21 [default = 10000];
  bool has_max_number_of_explored_assignments_per_try_in_ls() const;
  void clear_max_number_of_explored_assignments_per_try_in_ls();
  static const int kMaxNumberOfExploredAssignmentsPerTryInLsFieldNumber = 21;
  ::google::protobuf::int64 max_number_of_explored_assignments_per_try_in_ls() const;
  void set_max_number_of_explored_assignments_per_try_in_ls(::google::protobuf::int64 value);

  // optional bool use_transposition_table_in_ls = 22 [default = true];
  bool has_use_transposition_table_in_ls() const;
  void clear_use_transposition_table_in_ls();
  static const int kUseTranspositionTableInLsFieldNumber = 22;
  bool use_transposition_table_in_ls() const;
  void set_use_transposition_table_in_ls(bool value);

  // optional bool use_potential_one_flip_repairs_in_ls = 39 [default = false];
  bool has_use_potential_one_flip_repairs_in_ls() const;
  void clear_use_potential_one_flip_repairs_in_ls();
  static const int kUsePotentialOneFlipRepairsInLsFieldNumber = 39;
  bool use_potential_one_flip_repairs_in_ls() const;
  void set_use_potential_one_flip_repairs_in_ls(bool value);

  // optional bool use_learned_binary_clauses_in_lp = 23 [default = true];
  bool has_use_learned_binary_clauses_in_lp() const;
  void clear_use_learned_binary_clauses_in_lp();
  static const int kUseLearnedBinaryClausesInLpFieldNumber = 23;
  bool use_learned_binary_clauses_in_lp() const;
  void set_use_learned_binary_clauses_in_lp(bool value);

  // optional int32 number_of_solvers = 24 [default = 1];
  bool has_number_of_solvers() const;
  void clear_number_of_solvers();
  static const int kNumberOfSolversFieldNumber = 24;
  ::google::protobuf::int32 number_of_solvers() const;
  void set_number_of_solvers(::google::protobuf::int32 value);

  // optional .operations_research.bop.BopParameters.ThreadSynchronizationType synchronization_type = 25 [default = NO_SYNCHRONIZATION];
  bool has_synchronization_type() const;
  void clear_synchronization_type();
  static const int kSynchronizationTypeFieldNumber = 25;
  ::operations_research::bop::BopParameters_ThreadSynchronizationType synchronization_type() const;
  void set_synchronization_type(::operations_research::bop::BopParameters_ThreadSynchronizationType value);

  // repeated .operations_research.bop.BopSolverOptimizerSet solver_optimizer_sets = 26;
  int solver_optimizer_sets_size() const;
  void clear_solver_optimizer_sets();
  static const int kSolverOptimizerSetsFieldNumber = 26;
  const ::operations_research::bop::BopSolverOptimizerSet& solver_optimizer_sets(int index) const;
  ::operations_research::bop::BopSolverOptimizerSet* mutable_solver_optimizer_sets(int index);
  ::operations_research::bop::BopSolverOptimizerSet* add_solver_optimizer_sets();
  ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopSolverOptimizerSet >*
      mutable_solver_optimizer_sets();
  const ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopSolverOptimizerSet >&
      solver_optimizer_sets() const;

  // optional string default_solver_optimizer_sets = 33 [default = "methods:{type:LOCAL_SEARCH }                       methods:{type:RANDOM_FIRST_SOLUTION }              methods:{type:LINEAR_RELAXATION }                  methods:{type:LP_FIRST_SOLUTION }                  methods:{type:OBJECTIVE_FIRST_SOLUTION }           methods:{type:USER_GUIDED_FIRST_SOLUTION }         methods:{type:RANDOM_CONSTRAINT_LNS_GUIDED_BY_LP } methods:{type:RANDOM_VARIABLE_LNS_GUIDED_BY_LP }   methods:{type:RELATION_GRAPH_LNS }                 methods:{type:RELATION_GRAPH_LNS_GUIDED_BY_LP }    methods:{type:RANDOM_CONSTRAINT_LNS }              methods:{type:RANDOM_VARIABLE_LNS }                methods:{type:SAT_CORE_BASED }                     methods:{type:COMPLETE_LNS }                       "];
  bool has_default_solver_optimizer_sets() const;
  void clear_default_solver_optimizer_sets();
  static const int kDefaultSolverOptimizerSetsFieldNumber = 33;
  const ::std::string& default_solver_optimizer_sets() const;
  void set_default_solver_optimizer_sets(const ::std::string& value);
  void set_default_solver_optimizer_sets(const char* value);
  void set_default_solver_optimizer_sets(const char* value, size_t size);
  ::std::string* mutable_default_solver_optimizer_sets();
  ::std::string* release_default_solver_optimizer_sets();
  void set_allocated_default_solver_optimizer_sets(::std::string* default_solver_optimizer_sets);

  // optional bool use_lp_strong_branching = 29 [default = false];
  bool has_use_lp_strong_branching() const;
  void clear_use_lp_strong_branching();
  static const int kUseLpStrongBranchingFieldNumber = 29;
  bool use_lp_strong_branching() const;
  void set_use_lp_strong_branching(bool value);

  // optional int32 decomposer_num_variables_threshold = 30 [default = 50];
  bool has_decomposer_num_variables_threshold() const;
  void clear_decomposer_num_variables_threshold();
  static const int kDecomposerNumVariablesThresholdFieldNumber = 30;
  ::google::protobuf::int32 decomposer_num_variables_threshold() const;
  void set_decomposer_num_variables_threshold(::google::protobuf::int32 value);

  // optional int32 num_bop_solvers_used_by_decomposition = 31 [default = 1];
  bool has_num_bop_solvers_used_by_decomposition() const;
  void clear_num_bop_solvers_used_by_decomposition();
  static const int kNumBopSolversUsedByDecompositionFieldNumber = 31;
  ::google::protobuf::int32 num_bop_solvers_used_by_decomposition() const;
  void set_num_bop_solvers_used_by_decomposition(::google::protobuf::int32 value);

  // optional double decomposed_problem_min_time_in_seconds = 36 [default = 0];
  bool has_decomposed_problem_min_time_in_seconds() const;
  void clear_decomposed_problem_min_time_in_seconds();
  static const int kDecomposedProblemMinTimeInSecondsFieldNumber = 36;
  double decomposed_problem_min_time_in_seconds() const;
  void set_decomposed_problem_min_time_in_seconds(double value);

  // optional int32 guided_sat_conflicts_chunk = 34 [default = 1000];
  bool has_guided_sat_conflicts_chunk() const;
  void clear_guided_sat_conflicts_chunk();
  static const int kGuidedSatConflictsChunkFieldNumber = 34;
  ::google::protobuf::int32 guided_sat_conflicts_chunk() const;
  void set_guided_sat_conflicts_chunk(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:operations_research.bop.BopParameters)
 private:
  inline void set_has_max_time_in_seconds();
  inline void clear_has_max_time_in_seconds();
  inline void set_has_max_deterministic_time();
  inline void clear_has_max_deterministic_time();
  inline void set_has_lp_max_deterministic_time();
  inline void clear_has_lp_max_deterministic_time();
  inline void set_has_max_number_of_consecutive_failing_optimizer_calls();
  inline void clear_has_max_number_of_consecutive_failing_optimizer_calls();
  inline void set_has_relative_gap_limit();
  inline void clear_has_relative_gap_limit();
  inline void set_has_max_num_decisions_in_ls();
  inline void clear_has_max_num_decisions_in_ls();
  inline void set_has_max_num_broken_constraints_in_ls();
  inline void clear_has_max_num_broken_constraints_in_ls();
  inline void set_has_log_search_progress();
  inline void clear_has_log_search_progress();
  inline void set_has_compute_estimated_impact();
  inline void clear_has_compute_estimated_impact();
  inline void set_has_prune_search_tree();
  inline void clear_has_prune_search_tree();
  inline void set_has_sort_constraints_by_num_terms();
  inline void clear_has_sort_constraints_by_num_terms();
  inline void set_has_use_random_lns();
  inline void clear_has_use_random_lns();
  inline void set_has_random_seed();
  inline void clear_has_random_seed();
  inline void set_has_num_relaxed_vars();
  inline void clear_has_num_relaxed_vars();
  inline void set_has_max_number_of_conflicts_in_random_lns();
  inline void clear_has_max_number_of_conflicts_in_random_lns();
  inline void set_has_num_random_lns_tries();
  inline void clear_has_num_random_lns_tries();
  inline void set_has_max_number_of_backtracks_in_ls();
  inline void clear_has_max_number_of_backtracks_in_ls();
  inline void set_has_use_lp_lns();
  inline void clear_has_use_lp_lns();
  inline void set_has_use_sat_to_choose_lns_neighbourhood();
  inline void clear_has_use_sat_to_choose_lns_neighbourhood();
  inline void set_has_max_number_of_conflicts_for_quick_check();
  inline void clear_has_max_number_of_conflicts_for_quick_check();
  inline void set_has_use_symmetry();
  inline void clear_has_use_symmetry();
  inline void set_has_exploit_symmetry_in_sat_first_solution();
  inline void clear_has_exploit_symmetry_in_sat_first_solution();
  inline void set_has_max_number_of_conflicts_in_random_solution_generation();
  inline void clear_has_max_number_of_conflicts_in_random_solution_generation();
  inline void set_has_max_number_of_explored_assignments_per_try_in_ls();
  inline void clear_has_max_number_of_explored_assignments_per_try_in_ls();
  inline void set_has_use_transposition_table_in_ls();
  inline void clear_has_use_transposition_table_in_ls();
  inline void set_has_use_potential_one_flip_repairs_in_ls();
  inline void clear_has_use_potential_one_flip_repairs_in_ls();
  inline void set_has_use_learned_binary_clauses_in_lp();
  inline void clear_has_use_learned_binary_clauses_in_lp();
  inline void set_has_number_of_solvers();
  inline void clear_has_number_of_solvers();
  inline void set_has_synchronization_type();
  inline void clear_has_synchronization_type();
  inline void set_has_default_solver_optimizer_sets();
  inline void clear_has_default_solver_optimizer_sets();
  inline void set_has_use_lp_strong_branching();
  inline void clear_has_use_lp_strong_branching();
  inline void set_has_decomposer_num_variables_threshold();
  inline void clear_has_decomposer_num_variables_threshold();
  inline void set_has_num_bop_solvers_used_by_decomposition();
  inline void clear_has_num_bop_solvers_used_by_decomposition();
  inline void set_has_decomposed_problem_min_time_in_seconds();
  inline void clear_has_decomposed_problem_min_time_in_seconds();
  inline void set_has_guided_sat_conflicts_chunk();
  inline void clear_has_guided_sat_conflicts_chunk();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[2];
  double max_time_in_seconds_;
  double max_deterministic_time_;
  double lp_max_deterministic_time_;
  double relative_gap_limit_;
  ::google::protobuf::int32 max_number_of_consecutive_failing_optimizer_calls_;
  ::google::protobuf::int32 max_num_decisions_in_ls_;
  ::google::protobuf::int32 max_num_broken_constraints_in_ls_;
  bool log_search_progress_;
  bool compute_estimated_impact_;
  bool prune_search_tree_;
  bool sort_constraints_by_num_terms_;
  ::google::protobuf::int32 random_seed_;
  ::google::protobuf::int32 num_relaxed_vars_;
  ::google::protobuf::int32 max_number_of_conflicts_in_random_lns_;
  ::google::protobuf::int32 num_random_lns_tries_;
  ::google::protobuf::int64 max_number_of_backtracks_in_ls_;
  bool use_random_lns_;
  bool use_lp_lns_;
  bool use_sat_to_choose_lns_neighbourhood_;
  bool use_symmetry_;
  ::google::protobuf::int32 max_number_of_conflicts_for_quick_check_;
  ::google::protobuf::int64 max_number_of_explored_assignments_per_try_in_ls_;
  ::google::protobuf::int32 max_number_of_conflicts_in_random_solution_generation_;
  bool exploit_symmetry_in_sat_first_solution_;
  bool use_transposition_table_in_ls_;
  bool use_potential_one_flip_repairs_in_ls_;
  bool use_learned_binary_clauses_in_lp_;
  ::google::protobuf::int32 number_of_solvers_;
  int synchronization_type_;
  ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopSolverOptimizerSet > solver_optimizer_sets_;
  static ::std::string* _default_default_solver_optimizer_sets_;
  ::google::protobuf::internal::ArenaStringPtr default_solver_optimizer_sets_;
  bool use_lp_strong_branching_;
  ::google::protobuf::int32 decomposer_num_variables_threshold_;
  double decomposed_problem_min_time_in_seconds_;
  ::google::protobuf::int32 num_bop_solvers_used_by_decomposition_;
  ::google::protobuf::int32 guided_sat_conflicts_chunk_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_bop_2fbop_5fparameters_2eproto();
  friend void protobuf_AssignDesc_bop_2fbop_5fparameters_2eproto();
  friend void protobuf_ShutdownFile_bop_2fbop_5fparameters_2eproto();

  void InitAsDefaultInstance();
  static BopParameters* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// BopOptimizerMethod

// optional .operations_research.bop.BopOptimizerMethod.OptimizerType type = 1;
inline bool BopOptimizerMethod::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BopOptimizerMethod::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BopOptimizerMethod::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BopOptimizerMethod::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::operations_research::bop::BopOptimizerMethod_OptimizerType BopOptimizerMethod::type() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopOptimizerMethod.type)
  return static_cast< ::operations_research::bop::BopOptimizerMethod_OptimizerType >(type_);
}
inline void BopOptimizerMethod::set_type(::operations_research::bop::BopOptimizerMethod_OptimizerType value) {
  assert(::operations_research::bop::BopOptimizerMethod_OptimizerType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopOptimizerMethod.type)
}

// -------------------------------------------------------------------

// BopSolverOptimizerSet

// repeated .operations_research.bop.BopOptimizerMethod methods = 1;
inline int BopSolverOptimizerSet::methods_size() const {
  return methods_.size();
}
inline void BopSolverOptimizerSet::clear_methods() {
  methods_.Clear();
}
inline const ::operations_research::bop::BopOptimizerMethod& BopSolverOptimizerSet::methods(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopSolverOptimizerSet.methods)
  return methods_.Get(index);
}
inline ::operations_research::bop::BopOptimizerMethod* BopSolverOptimizerSet::mutable_methods(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.bop.BopSolverOptimizerSet.methods)
  return methods_.Mutable(index);
}
inline ::operations_research::bop::BopOptimizerMethod* BopSolverOptimizerSet::add_methods() {
  // @@protoc_insertion_point(field_add:operations_research.bop.BopSolverOptimizerSet.methods)
  return methods_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopOptimizerMethod >*
BopSolverOptimizerSet::mutable_methods() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.bop.BopSolverOptimizerSet.methods)
  return &methods_;
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopOptimizerMethod >&
BopSolverOptimizerSet::methods() const {
  // @@protoc_insertion_point(field_list:operations_research.bop.BopSolverOptimizerSet.methods)
  return methods_;
}

// -------------------------------------------------------------------

// BopParameters

// optional double max_time_in_seconds = 1 [default = inf];
inline bool BopParameters::has_max_time_in_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BopParameters::set_has_max_time_in_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BopParameters::clear_has_max_time_in_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BopParameters::clear_max_time_in_seconds() {
  max_time_in_seconds_ = ::google::protobuf::internal::Infinity();
  clear_has_max_time_in_seconds();
}
inline double BopParameters::max_time_in_seconds() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_time_in_seconds)
  return max_time_in_seconds_;
}
inline void BopParameters::set_max_time_in_seconds(double value) {
  set_has_max_time_in_seconds();
  max_time_in_seconds_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_time_in_seconds)
}

// optional double max_deterministic_time = 27 [default = inf];
inline bool BopParameters::has_max_deterministic_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BopParameters::set_has_max_deterministic_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BopParameters::clear_has_max_deterministic_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BopParameters::clear_max_deterministic_time() {
  max_deterministic_time_ = ::google::protobuf::internal::Infinity();
  clear_has_max_deterministic_time();
}
inline double BopParameters::max_deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_deterministic_time)
  return max_deterministic_time_;
}
inline void BopParameters::set_max_deterministic_time(double value) {
  set_has_max_deterministic_time();
  max_deterministic_time_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_deterministic_time)
}

// optional double lp_max_deterministic_time = 37 [default = 1];
inline bool BopParameters::has_lp_max_deterministic_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BopParameters::set_has_lp_max_deterministic_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BopParameters::clear_has_lp_max_deterministic_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BopParameters::clear_lp_max_deterministic_time() {
  lp_max_deterministic_time_ = 1;
  clear_has_lp_max_deterministic_time();
}
inline double BopParameters::lp_max_deterministic_time() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.lp_max_deterministic_time)
  return lp_max_deterministic_time_;
}
inline void BopParameters::set_lp_max_deterministic_time(double value) {
  set_has_lp_max_deterministic_time();
  lp_max_deterministic_time_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.lp_max_deterministic_time)
}

// optional int32 max_number_of_consecutive_failing_optimizer_calls = 35;
inline bool BopParameters::has_max_number_of_consecutive_failing_optimizer_calls() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BopParameters::set_has_max_number_of_consecutive_failing_optimizer_calls() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BopParameters::clear_has_max_number_of_consecutive_failing_optimizer_calls() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BopParameters::clear_max_number_of_consecutive_failing_optimizer_calls() {
  max_number_of_consecutive_failing_optimizer_calls_ = 0;
  clear_has_max_number_of_consecutive_failing_optimizer_calls();
}
inline ::google::protobuf::int32 BopParameters::max_number_of_consecutive_failing_optimizer_calls() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_number_of_consecutive_failing_optimizer_calls)
  return max_number_of_consecutive_failing_optimizer_calls_;
}
inline void BopParameters::set_max_number_of_consecutive_failing_optimizer_calls(::google::protobuf::int32 value) {
  set_has_max_number_of_consecutive_failing_optimizer_calls();
  max_number_of_consecutive_failing_optimizer_calls_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_number_of_consecutive_failing_optimizer_calls)
}

// optional double relative_gap_limit = 28 [default = 0.0001];
inline bool BopParameters::has_relative_gap_limit() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BopParameters::set_has_relative_gap_limit() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BopParameters::clear_has_relative_gap_limit() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BopParameters::clear_relative_gap_limit() {
  relative_gap_limit_ = 0.0001;
  clear_has_relative_gap_limit();
}
inline double BopParameters::relative_gap_limit() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.relative_gap_limit)
  return relative_gap_limit_;
}
inline void BopParameters::set_relative_gap_limit(double value) {
  set_has_relative_gap_limit();
  relative_gap_limit_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.relative_gap_limit)
}

// optional int32 max_num_decisions_in_ls = 2 [default = 4];
inline bool BopParameters::has_max_num_decisions_in_ls() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BopParameters::set_has_max_num_decisions_in_ls() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BopParameters::clear_has_max_num_decisions_in_ls() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BopParameters::clear_max_num_decisions_in_ls() {
  max_num_decisions_in_ls_ = 4;
  clear_has_max_num_decisions_in_ls();
}
inline ::google::protobuf::int32 BopParameters::max_num_decisions_in_ls() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_num_decisions_in_ls)
  return max_num_decisions_in_ls_;
}
inline void BopParameters::set_max_num_decisions_in_ls(::google::protobuf::int32 value) {
  set_has_max_num_decisions_in_ls();
  max_num_decisions_in_ls_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_num_decisions_in_ls)
}

// optional int32 max_num_broken_constraints_in_ls = 38 [default = 2147483647];
inline bool BopParameters::has_max_num_broken_constraints_in_ls() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BopParameters::set_has_max_num_broken_constraints_in_ls() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BopParameters::clear_has_max_num_broken_constraints_in_ls() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BopParameters::clear_max_num_broken_constraints_in_ls() {
  max_num_broken_constraints_in_ls_ = 2147483647;
  clear_has_max_num_broken_constraints_in_ls();
}
inline ::google::protobuf::int32 BopParameters::max_num_broken_constraints_in_ls() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_num_broken_constraints_in_ls)
  return max_num_broken_constraints_in_ls_;
}
inline void BopParameters::set_max_num_broken_constraints_in_ls(::google::protobuf::int32 value) {
  set_has_max_num_broken_constraints_in_ls();
  max_num_broken_constraints_in_ls_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_num_broken_constraints_in_ls)
}

// optional bool log_search_progress = 14 [default = false];
inline bool BopParameters::has_log_search_progress() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BopParameters::set_has_log_search_progress() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BopParameters::clear_has_log_search_progress() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BopParameters::clear_log_search_progress() {
  log_search_progress_ = false;
  clear_has_log_search_progress();
}
inline bool BopParameters::log_search_progress() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.log_search_progress)
  return log_search_progress_;
}
inline void BopParameters::set_log_search_progress(bool value) {
  set_has_log_search_progress();
  log_search_progress_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.log_search_progress)
}

// optional bool compute_estimated_impact = 3 [default = true];
inline bool BopParameters::has_compute_estimated_impact() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BopParameters::set_has_compute_estimated_impact() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BopParameters::clear_has_compute_estimated_impact() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BopParameters::clear_compute_estimated_impact() {
  compute_estimated_impact_ = true;
  clear_has_compute_estimated_impact();
}
inline bool BopParameters::compute_estimated_impact() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.compute_estimated_impact)
  return compute_estimated_impact_;
}
inline void BopParameters::set_compute_estimated_impact(bool value) {
  set_has_compute_estimated_impact();
  compute_estimated_impact_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.compute_estimated_impact)
}

// optional bool prune_search_tree = 4 [default = false];
inline bool BopParameters::has_prune_search_tree() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void BopParameters::set_has_prune_search_tree() {
  _has_bits_[0] |= 0x00000200u;
}
inline void BopParameters::clear_has_prune_search_tree() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void BopParameters::clear_prune_search_tree() {
  prune_search_tree_ = false;
  clear_has_prune_search_tree();
}
inline bool BopParameters::prune_search_tree() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.prune_search_tree)
  return prune_search_tree_;
}
inline void BopParameters::set_prune_search_tree(bool value) {
  set_has_prune_search_tree();
  prune_search_tree_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.prune_search_tree)
}

// optional bool sort_constraints_by_num_terms = 5 [default = false];
inline bool BopParameters::has_sort_constraints_by_num_terms() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void BopParameters::set_has_sort_constraints_by_num_terms() {
  _has_bits_[0] |= 0x00000400u;
}
inline void BopParameters::clear_has_sort_constraints_by_num_terms() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void BopParameters::clear_sort_constraints_by_num_terms() {
  sort_constraints_by_num_terms_ = false;
  clear_has_sort_constraints_by_num_terms();
}
inline bool BopParameters::sort_constraints_by_num_terms() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.sort_constraints_by_num_terms)
  return sort_constraints_by_num_terms_;
}
inline void BopParameters::set_sort_constraints_by_num_terms(bool value) {
  set_has_sort_constraints_by_num_terms();
  sort_constraints_by_num_terms_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.sort_constraints_by_num_terms)
}

// optional bool use_random_lns = 6 [default = true];
inline bool BopParameters::has_use_random_lns() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void BopParameters::set_has_use_random_lns() {
  _has_bits_[0] |= 0x00000800u;
}
inline void BopParameters::clear_has_use_random_lns() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void BopParameters::clear_use_random_lns() {
  use_random_lns_ = true;
  clear_has_use_random_lns();
}
inline bool BopParameters::use_random_lns() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_random_lns)
  return use_random_lns_;
}
inline void BopParameters::set_use_random_lns(bool value) {
  set_has_use_random_lns();
  use_random_lns_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_random_lns)
}

// optional int32 random_seed = 7 [default = 0];
inline bool BopParameters::has_random_seed() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void BopParameters::set_has_random_seed() {
  _has_bits_[0] |= 0x00001000u;
}
inline void BopParameters::clear_has_random_seed() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void BopParameters::clear_random_seed() {
  random_seed_ = 0;
  clear_has_random_seed();
}
inline ::google::protobuf::int32 BopParameters::random_seed() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.random_seed)
  return random_seed_;
}
inline void BopParameters::set_random_seed(::google::protobuf::int32 value) {
  set_has_random_seed();
  random_seed_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.random_seed)
}

// optional int32 num_relaxed_vars = 8 [default = 10];
inline bool BopParameters::has_num_relaxed_vars() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void BopParameters::set_has_num_relaxed_vars() {
  _has_bits_[0] |= 0x00002000u;
}
inline void BopParameters::clear_has_num_relaxed_vars() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void BopParameters::clear_num_relaxed_vars() {
  num_relaxed_vars_ = 10;
  clear_has_num_relaxed_vars();
}
inline ::google::protobuf::int32 BopParameters::num_relaxed_vars() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.num_relaxed_vars)
  return num_relaxed_vars_;
}
inline void BopParameters::set_num_relaxed_vars(::google::protobuf::int32 value) {
  set_has_num_relaxed_vars();
  num_relaxed_vars_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.num_relaxed_vars)
}

// optional int32 max_number_of_conflicts_in_random_lns = 9 [default = 2500];
inline bool BopParameters::has_max_number_of_conflicts_in_random_lns() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void BopParameters::set_has_max_number_of_conflicts_in_random_lns() {
  _has_bits_[0] |= 0x00004000u;
}
inline void BopParameters::clear_has_max_number_of_conflicts_in_random_lns() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void BopParameters::clear_max_number_of_conflicts_in_random_lns() {
  max_number_of_conflicts_in_random_lns_ = 2500;
  clear_has_max_number_of_conflicts_in_random_lns();
}
inline ::google::protobuf::int32 BopParameters::max_number_of_conflicts_in_random_lns() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_number_of_conflicts_in_random_lns)
  return max_number_of_conflicts_in_random_lns_;
}
inline void BopParameters::set_max_number_of_conflicts_in_random_lns(::google::protobuf::int32 value) {
  set_has_max_number_of_conflicts_in_random_lns();
  max_number_of_conflicts_in_random_lns_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_number_of_conflicts_in_random_lns)
}

// optional int32 num_random_lns_tries = 10 [default = 1];
inline bool BopParameters::has_num_random_lns_tries() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void BopParameters::set_has_num_random_lns_tries() {
  _has_bits_[0] |= 0x00008000u;
}
inline void BopParameters::clear_has_num_random_lns_tries() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void BopParameters::clear_num_random_lns_tries() {
  num_random_lns_tries_ = 1;
  clear_has_num_random_lns_tries();
}
inline ::google::protobuf::int32 BopParameters::num_random_lns_tries() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.num_random_lns_tries)
  return num_random_lns_tries_;
}
inline void BopParameters::set_num_random_lns_tries(::google::protobuf::int32 value) {
  set_has_num_random_lns_tries();
  num_random_lns_tries_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.num_random_lns_tries)
}

// optional int64 max_number_of_backtracks_in_ls = 11 [default = 100000000];
inline bool BopParameters::has_max_number_of_backtracks_in_ls() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void BopParameters::set_has_max_number_of_backtracks_in_ls() {
  _has_bits_[0] |= 0x00010000u;
}
inline void BopParameters::clear_has_max_number_of_backtracks_in_ls() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void BopParameters::clear_max_number_of_backtracks_in_ls() {
  max_number_of_backtracks_in_ls_ = GOOGLE_LONGLONG(100000000);
  clear_has_max_number_of_backtracks_in_ls();
}
inline ::google::protobuf::int64 BopParameters::max_number_of_backtracks_in_ls() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_number_of_backtracks_in_ls)
  return max_number_of_backtracks_in_ls_;
}
inline void BopParameters::set_max_number_of_backtracks_in_ls(::google::protobuf::int64 value) {
  set_has_max_number_of_backtracks_in_ls();
  max_number_of_backtracks_in_ls_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_number_of_backtracks_in_ls)
}

// optional bool use_lp_lns = 12 [default = true];
inline bool BopParameters::has_use_lp_lns() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void BopParameters::set_has_use_lp_lns() {
  _has_bits_[0] |= 0x00020000u;
}
inline void BopParameters::clear_has_use_lp_lns() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void BopParameters::clear_use_lp_lns() {
  use_lp_lns_ = true;
  clear_has_use_lp_lns();
}
inline bool BopParameters::use_lp_lns() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_lp_lns)
  return use_lp_lns_;
}
inline void BopParameters::set_use_lp_lns(bool value) {
  set_has_use_lp_lns();
  use_lp_lns_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_lp_lns)
}

// optional bool use_sat_to_choose_lns_neighbourhood = 15 [default = true];
inline bool BopParameters::has_use_sat_to_choose_lns_neighbourhood() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void BopParameters::set_has_use_sat_to_choose_lns_neighbourhood() {
  _has_bits_[0] |= 0x00040000u;
}
inline void BopParameters::clear_has_use_sat_to_choose_lns_neighbourhood() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void BopParameters::clear_use_sat_to_choose_lns_neighbourhood() {
  use_sat_to_choose_lns_neighbourhood_ = true;
  clear_has_use_sat_to_choose_lns_neighbourhood();
}
inline bool BopParameters::use_sat_to_choose_lns_neighbourhood() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_sat_to_choose_lns_neighbourhood)
  return use_sat_to_choose_lns_neighbourhood_;
}
inline void BopParameters::set_use_sat_to_choose_lns_neighbourhood(bool value) {
  set_has_use_sat_to_choose_lns_neighbourhood();
  use_sat_to_choose_lns_neighbourhood_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_sat_to_choose_lns_neighbourhood)
}

// optional int32 max_number_of_conflicts_for_quick_check = 16 [default = 10];
inline bool BopParameters::has_max_number_of_conflicts_for_quick_check() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void BopParameters::set_has_max_number_of_conflicts_for_quick_check() {
  _has_bits_[0] |= 0x00080000u;
}
inline void BopParameters::clear_has_max_number_of_conflicts_for_quick_check() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void BopParameters::clear_max_number_of_conflicts_for_quick_check() {
  max_number_of_conflicts_for_quick_check_ = 10;
  clear_has_max_number_of_conflicts_for_quick_check();
}
inline ::google::protobuf::int32 BopParameters::max_number_of_conflicts_for_quick_check() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_number_of_conflicts_for_quick_check)
  return max_number_of_conflicts_for_quick_check_;
}
inline void BopParameters::set_max_number_of_conflicts_for_quick_check(::google::protobuf::int32 value) {
  set_has_max_number_of_conflicts_for_quick_check();
  max_number_of_conflicts_for_quick_check_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_number_of_conflicts_for_quick_check)
}

// optional bool use_symmetry = 17 [default = false];
inline bool BopParameters::has_use_symmetry() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void BopParameters::set_has_use_symmetry() {
  _has_bits_[0] |= 0x00100000u;
}
inline void BopParameters::clear_has_use_symmetry() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void BopParameters::clear_use_symmetry() {
  use_symmetry_ = false;
  clear_has_use_symmetry();
}
inline bool BopParameters::use_symmetry() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_symmetry)
  return use_symmetry_;
}
inline void BopParameters::set_use_symmetry(bool value) {
  set_has_use_symmetry();
  use_symmetry_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_symmetry)
}

// optional bool exploit_symmetry_in_sat_first_solution = 40 [default = false];
inline bool BopParameters::has_exploit_symmetry_in_sat_first_solution() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void BopParameters::set_has_exploit_symmetry_in_sat_first_solution() {
  _has_bits_[0] |= 0x00200000u;
}
inline void BopParameters::clear_has_exploit_symmetry_in_sat_first_solution() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void BopParameters::clear_exploit_symmetry_in_sat_first_solution() {
  exploit_symmetry_in_sat_first_solution_ = false;
  clear_has_exploit_symmetry_in_sat_first_solution();
}
inline bool BopParameters::exploit_symmetry_in_sat_first_solution() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.exploit_symmetry_in_sat_first_solution)
  return exploit_symmetry_in_sat_first_solution_;
}
inline void BopParameters::set_exploit_symmetry_in_sat_first_solution(bool value) {
  set_has_exploit_symmetry_in_sat_first_solution();
  exploit_symmetry_in_sat_first_solution_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.exploit_symmetry_in_sat_first_solution)
}

// optional int32 max_number_of_conflicts_in_random_solution_generation = 20 [default = 500];
inline bool BopParameters::has_max_number_of_conflicts_in_random_solution_generation() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void BopParameters::set_has_max_number_of_conflicts_in_random_solution_generation() {
  _has_bits_[0] |= 0x00400000u;
}
inline void BopParameters::clear_has_max_number_of_conflicts_in_random_solution_generation() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void BopParameters::clear_max_number_of_conflicts_in_random_solution_generation() {
  max_number_of_conflicts_in_random_solution_generation_ = 500;
  clear_has_max_number_of_conflicts_in_random_solution_generation();
}
inline ::google::protobuf::int32 BopParameters::max_number_of_conflicts_in_random_solution_generation() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_number_of_conflicts_in_random_solution_generation)
  return max_number_of_conflicts_in_random_solution_generation_;
}
inline void BopParameters::set_max_number_of_conflicts_in_random_solution_generation(::google::protobuf::int32 value) {
  set_has_max_number_of_conflicts_in_random_solution_generation();
  max_number_of_conflicts_in_random_solution_generation_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_number_of_conflicts_in_random_solution_generation)
}

// optional int64 max_number_of_explored_assignments_per_try_in_ls = 21 [default = 10000];
inline bool BopParameters::has_max_number_of_explored_assignments_per_try_in_ls() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void BopParameters::set_has_max_number_of_explored_assignments_per_try_in_ls() {
  _has_bits_[0] |= 0x00800000u;
}
inline void BopParameters::clear_has_max_number_of_explored_assignments_per_try_in_ls() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void BopParameters::clear_max_number_of_explored_assignments_per_try_in_ls() {
  max_number_of_explored_assignments_per_try_in_ls_ = GOOGLE_LONGLONG(10000);
  clear_has_max_number_of_explored_assignments_per_try_in_ls();
}
inline ::google::protobuf::int64 BopParameters::max_number_of_explored_assignments_per_try_in_ls() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.max_number_of_explored_assignments_per_try_in_ls)
  return max_number_of_explored_assignments_per_try_in_ls_;
}
inline void BopParameters::set_max_number_of_explored_assignments_per_try_in_ls(::google::protobuf::int64 value) {
  set_has_max_number_of_explored_assignments_per_try_in_ls();
  max_number_of_explored_assignments_per_try_in_ls_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.max_number_of_explored_assignments_per_try_in_ls)
}

// optional bool use_transposition_table_in_ls = 22 [default = true];
inline bool BopParameters::has_use_transposition_table_in_ls() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void BopParameters::set_has_use_transposition_table_in_ls() {
  _has_bits_[0] |= 0x01000000u;
}
inline void BopParameters::clear_has_use_transposition_table_in_ls() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void BopParameters::clear_use_transposition_table_in_ls() {
  use_transposition_table_in_ls_ = true;
  clear_has_use_transposition_table_in_ls();
}
inline bool BopParameters::use_transposition_table_in_ls() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_transposition_table_in_ls)
  return use_transposition_table_in_ls_;
}
inline void BopParameters::set_use_transposition_table_in_ls(bool value) {
  set_has_use_transposition_table_in_ls();
  use_transposition_table_in_ls_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_transposition_table_in_ls)
}

// optional bool use_potential_one_flip_repairs_in_ls = 39 [default = false];
inline bool BopParameters::has_use_potential_one_flip_repairs_in_ls() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void BopParameters::set_has_use_potential_one_flip_repairs_in_ls() {
  _has_bits_[0] |= 0x02000000u;
}
inline void BopParameters::clear_has_use_potential_one_flip_repairs_in_ls() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void BopParameters::clear_use_potential_one_flip_repairs_in_ls() {
  use_potential_one_flip_repairs_in_ls_ = false;
  clear_has_use_potential_one_flip_repairs_in_ls();
}
inline bool BopParameters::use_potential_one_flip_repairs_in_ls() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_potential_one_flip_repairs_in_ls)
  return use_potential_one_flip_repairs_in_ls_;
}
inline void BopParameters::set_use_potential_one_flip_repairs_in_ls(bool value) {
  set_has_use_potential_one_flip_repairs_in_ls();
  use_potential_one_flip_repairs_in_ls_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_potential_one_flip_repairs_in_ls)
}

// optional bool use_learned_binary_clauses_in_lp = 23 [default = true];
inline bool BopParameters::has_use_learned_binary_clauses_in_lp() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void BopParameters::set_has_use_learned_binary_clauses_in_lp() {
  _has_bits_[0] |= 0x04000000u;
}
inline void BopParameters::clear_has_use_learned_binary_clauses_in_lp() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void BopParameters::clear_use_learned_binary_clauses_in_lp() {
  use_learned_binary_clauses_in_lp_ = true;
  clear_has_use_learned_binary_clauses_in_lp();
}
inline bool BopParameters::use_learned_binary_clauses_in_lp() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_learned_binary_clauses_in_lp)
  return use_learned_binary_clauses_in_lp_;
}
inline void BopParameters::set_use_learned_binary_clauses_in_lp(bool value) {
  set_has_use_learned_binary_clauses_in_lp();
  use_learned_binary_clauses_in_lp_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_learned_binary_clauses_in_lp)
}

// optional int32 number_of_solvers = 24 [default = 1];
inline bool BopParameters::has_number_of_solvers() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void BopParameters::set_has_number_of_solvers() {
  _has_bits_[0] |= 0x08000000u;
}
inline void BopParameters::clear_has_number_of_solvers() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void BopParameters::clear_number_of_solvers() {
  number_of_solvers_ = 1;
  clear_has_number_of_solvers();
}
inline ::google::protobuf::int32 BopParameters::number_of_solvers() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.number_of_solvers)
  return number_of_solvers_;
}
inline void BopParameters::set_number_of_solvers(::google::protobuf::int32 value) {
  set_has_number_of_solvers();
  number_of_solvers_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.number_of_solvers)
}

// optional .operations_research.bop.BopParameters.ThreadSynchronizationType synchronization_type = 25 [default = NO_SYNCHRONIZATION];
inline bool BopParameters::has_synchronization_type() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void BopParameters::set_has_synchronization_type() {
  _has_bits_[0] |= 0x10000000u;
}
inline void BopParameters::clear_has_synchronization_type() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void BopParameters::clear_synchronization_type() {
  synchronization_type_ = 0;
  clear_has_synchronization_type();
}
inline ::operations_research::bop::BopParameters_ThreadSynchronizationType BopParameters::synchronization_type() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.synchronization_type)
  return static_cast< ::operations_research::bop::BopParameters_ThreadSynchronizationType >(synchronization_type_);
}
inline void BopParameters::set_synchronization_type(::operations_research::bop::BopParameters_ThreadSynchronizationType value) {
  assert(::operations_research::bop::BopParameters_ThreadSynchronizationType_IsValid(value));
  set_has_synchronization_type();
  synchronization_type_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.synchronization_type)
}

// repeated .operations_research.bop.BopSolverOptimizerSet solver_optimizer_sets = 26;
inline int BopParameters::solver_optimizer_sets_size() const {
  return solver_optimizer_sets_.size();
}
inline void BopParameters::clear_solver_optimizer_sets() {
  solver_optimizer_sets_.Clear();
}
inline const ::operations_research::bop::BopSolverOptimizerSet& BopParameters::solver_optimizer_sets(int index) const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.solver_optimizer_sets)
  return solver_optimizer_sets_.Get(index);
}
inline ::operations_research::bop::BopSolverOptimizerSet* BopParameters::mutable_solver_optimizer_sets(int index) {
  // @@protoc_insertion_point(field_mutable:operations_research.bop.BopParameters.solver_optimizer_sets)
  return solver_optimizer_sets_.Mutable(index);
}
inline ::operations_research::bop::BopSolverOptimizerSet* BopParameters::add_solver_optimizer_sets() {
  // @@protoc_insertion_point(field_add:operations_research.bop.BopParameters.solver_optimizer_sets)
  return solver_optimizer_sets_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopSolverOptimizerSet >*
BopParameters::mutable_solver_optimizer_sets() {
  // @@protoc_insertion_point(field_mutable_list:operations_research.bop.BopParameters.solver_optimizer_sets)
  return &solver_optimizer_sets_;
}
inline const ::google::protobuf::RepeatedPtrField< ::operations_research::bop::BopSolverOptimizerSet >&
BopParameters::solver_optimizer_sets() const {
  // @@protoc_insertion_point(field_list:operations_research.bop.BopParameters.solver_optimizer_sets)
  return solver_optimizer_sets_;
}

// optional string default_solver_optimizer_sets = 33 [default = "methods:{type:LOCAL_SEARCH }                       methods:{type:RANDOM_FIRST_SOLUTION }              methods:{type:LINEAR_RELAXATION }                  methods:{type:LP_FIRST_SOLUTION }                  methods:{type:OBJECTIVE_FIRST_SOLUTION }           methods:{type:USER_GUIDED_FIRST_SOLUTION }         methods:{type:RANDOM_CONSTRAINT_LNS_GUIDED_BY_LP } methods:{type:RANDOM_VARIABLE_LNS_GUIDED_BY_LP }   methods:{type:RELATION_GRAPH_LNS }                 methods:{type:RELATION_GRAPH_LNS_GUIDED_BY_LP }    methods:{type:RANDOM_CONSTRAINT_LNS }              methods:{type:RANDOM_VARIABLE_LNS }                methods:{type:SAT_CORE_BASED }                     methods:{type:COMPLETE_LNS }                       "];
inline bool BopParameters::has_default_solver_optimizer_sets() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void BopParameters::set_has_default_solver_optimizer_sets() {
  _has_bits_[0] |= 0x40000000u;
}
inline void BopParameters::clear_has_default_solver_optimizer_sets() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void BopParameters::clear_default_solver_optimizer_sets() {
  default_solver_optimizer_sets_.ClearToDefaultNoArena(_default_default_solver_optimizer_sets_);
  clear_has_default_solver_optimizer_sets();
}
inline const ::std::string& BopParameters::default_solver_optimizer_sets() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.default_solver_optimizer_sets)
  return default_solver_optimizer_sets_.GetNoArena(_default_default_solver_optimizer_sets_);
}
inline void BopParameters::set_default_solver_optimizer_sets(const ::std::string& value) {
  set_has_default_solver_optimizer_sets();
  default_solver_optimizer_sets_.SetNoArena(_default_default_solver_optimizer_sets_, value);
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.default_solver_optimizer_sets)
}
inline void BopParameters::set_default_solver_optimizer_sets(const char* value) {
  set_has_default_solver_optimizer_sets();
  default_solver_optimizer_sets_.SetNoArena(_default_default_solver_optimizer_sets_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:operations_research.bop.BopParameters.default_solver_optimizer_sets)
}
inline void BopParameters::set_default_solver_optimizer_sets(const char* value, size_t size) {
  set_has_default_solver_optimizer_sets();
  default_solver_optimizer_sets_.SetNoArena(_default_default_solver_optimizer_sets_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:operations_research.bop.BopParameters.default_solver_optimizer_sets)
}
inline ::std::string* BopParameters::mutable_default_solver_optimizer_sets() {
  set_has_default_solver_optimizer_sets();
  // @@protoc_insertion_point(field_mutable:operations_research.bop.BopParameters.default_solver_optimizer_sets)
  return default_solver_optimizer_sets_.MutableNoArena(_default_default_solver_optimizer_sets_);
}
inline ::std::string* BopParameters::release_default_solver_optimizer_sets() {
  // @@protoc_insertion_point(field_release:operations_research.bop.BopParameters.default_solver_optimizer_sets)
  clear_has_default_solver_optimizer_sets();
  return default_solver_optimizer_sets_.ReleaseNoArena(_default_default_solver_optimizer_sets_);
}
inline void BopParameters::set_allocated_default_solver_optimizer_sets(::std::string* default_solver_optimizer_sets) {
  if (default_solver_optimizer_sets != NULL) {
    set_has_default_solver_optimizer_sets();
  } else {
    clear_has_default_solver_optimizer_sets();
  }
  default_solver_optimizer_sets_.SetAllocatedNoArena(_default_default_solver_optimizer_sets_, default_solver_optimizer_sets);
  // @@protoc_insertion_point(field_set_allocated:operations_research.bop.BopParameters.default_solver_optimizer_sets)
}

// optional bool use_lp_strong_branching = 29 [default = false];
inline bool BopParameters::has_use_lp_strong_branching() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void BopParameters::set_has_use_lp_strong_branching() {
  _has_bits_[0] |= 0x80000000u;
}
inline void BopParameters::clear_has_use_lp_strong_branching() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void BopParameters::clear_use_lp_strong_branching() {
  use_lp_strong_branching_ = false;
  clear_has_use_lp_strong_branching();
}
inline bool BopParameters::use_lp_strong_branching() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.use_lp_strong_branching)
  return use_lp_strong_branching_;
}
inline void BopParameters::set_use_lp_strong_branching(bool value) {
  set_has_use_lp_strong_branching();
  use_lp_strong_branching_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.use_lp_strong_branching)
}

// optional int32 decomposer_num_variables_threshold = 30 [default = 50];
inline bool BopParameters::has_decomposer_num_variables_threshold() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void BopParameters::set_has_decomposer_num_variables_threshold() {
  _has_bits_[1] |= 0x00000001u;
}
inline void BopParameters::clear_has_decomposer_num_variables_threshold() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void BopParameters::clear_decomposer_num_variables_threshold() {
  decomposer_num_variables_threshold_ = 50;
  clear_has_decomposer_num_variables_threshold();
}
inline ::google::protobuf::int32 BopParameters::decomposer_num_variables_threshold() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.decomposer_num_variables_threshold)
  return decomposer_num_variables_threshold_;
}
inline void BopParameters::set_decomposer_num_variables_threshold(::google::protobuf::int32 value) {
  set_has_decomposer_num_variables_threshold();
  decomposer_num_variables_threshold_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.decomposer_num_variables_threshold)
}

// optional int32 num_bop_solvers_used_by_decomposition = 31 [default = 1];
inline bool BopParameters::has_num_bop_solvers_used_by_decomposition() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void BopParameters::set_has_num_bop_solvers_used_by_decomposition() {
  _has_bits_[1] |= 0x00000002u;
}
inline void BopParameters::clear_has_num_bop_solvers_used_by_decomposition() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void BopParameters::clear_num_bop_solvers_used_by_decomposition() {
  num_bop_solvers_used_by_decomposition_ = 1;
  clear_has_num_bop_solvers_used_by_decomposition();
}
inline ::google::protobuf::int32 BopParameters::num_bop_solvers_used_by_decomposition() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.num_bop_solvers_used_by_decomposition)
  return num_bop_solvers_used_by_decomposition_;
}
inline void BopParameters::set_num_bop_solvers_used_by_decomposition(::google::protobuf::int32 value) {
  set_has_num_bop_solvers_used_by_decomposition();
  num_bop_solvers_used_by_decomposition_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.num_bop_solvers_used_by_decomposition)
}

// optional double decomposed_problem_min_time_in_seconds = 36 [default = 0];
inline bool BopParameters::has_decomposed_problem_min_time_in_seconds() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void BopParameters::set_has_decomposed_problem_min_time_in_seconds() {
  _has_bits_[1] |= 0x00000004u;
}
inline void BopParameters::clear_has_decomposed_problem_min_time_in_seconds() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void BopParameters::clear_decomposed_problem_min_time_in_seconds() {
  decomposed_problem_min_time_in_seconds_ = 0;
  clear_has_decomposed_problem_min_time_in_seconds();
}
inline double BopParameters::decomposed_problem_min_time_in_seconds() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.decomposed_problem_min_time_in_seconds)
  return decomposed_problem_min_time_in_seconds_;
}
inline void BopParameters::set_decomposed_problem_min_time_in_seconds(double value) {
  set_has_decomposed_problem_min_time_in_seconds();
  decomposed_problem_min_time_in_seconds_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.decomposed_problem_min_time_in_seconds)
}

// optional int32 guided_sat_conflicts_chunk = 34 [default = 1000];
inline bool BopParameters::has_guided_sat_conflicts_chunk() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void BopParameters::set_has_guided_sat_conflicts_chunk() {
  _has_bits_[1] |= 0x00000008u;
}
inline void BopParameters::clear_has_guided_sat_conflicts_chunk() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void BopParameters::clear_guided_sat_conflicts_chunk() {
  guided_sat_conflicts_chunk_ = 1000;
  clear_has_guided_sat_conflicts_chunk();
}
inline ::google::protobuf::int32 BopParameters::guided_sat_conflicts_chunk() const {
  // @@protoc_insertion_point(field_get:operations_research.bop.BopParameters.guided_sat_conflicts_chunk)
  return guided_sat_conflicts_chunk_;
}
inline void BopParameters::set_guided_sat_conflicts_chunk(::google::protobuf::int32 value) {
  set_has_guided_sat_conflicts_chunk();
  guided_sat_conflicts_chunk_ = value;
  // @@protoc_insertion_point(field_set:operations_research.bop.BopParameters.guided_sat_conflicts_chunk)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace bop
}  // namespace operations_research

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::operations_research::bop::BopOptimizerMethod_OptimizerType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::bop::BopOptimizerMethod_OptimizerType>() {
  return ::operations_research::bop::BopOptimizerMethod_OptimizerType_descriptor();
}
template <> struct is_proto_enum< ::operations_research::bop::BopParameters_ThreadSynchronizationType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::operations_research::bop::BopParameters_ThreadSynchronizationType>() {
  return ::operations_research::bop::BopParameters_ThreadSynchronizationType_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bop_2fbop_5fparameters_2eproto__INCLUDED
